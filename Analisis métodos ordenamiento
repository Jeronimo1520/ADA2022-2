import time
import matplotlib.pyplot as grafica
import random

def generate_plot(my_function):
    times = []
    for i in range(1,700):
        #my_list = random.sample(range(0,i), i)#caso promedio: datos desordenados
        #my_list = list(range(i,0,-1))#peor caso
        my_list = list(range(0,i))#mejor caso: datos ordenados
        start_time = time.time()
        my_function(my_list)
        end_time = time.time()
        total_time = end_time - start_time
        times.append(total_time)
    
    grafica.plot(times)
    grafica.title("mejor caso")

    grafica.show()
    
def buble_sort(data):
    for i in range(len(data)-1):
        check_sort = True
        for j in range((len(data)-1)-i):
            if data[j]>data[j+1]:
                data[j],data[j+1] = data[j+1], data[j]
                check_sort = False
        if(check_sort):
            break
    return data       


def insertion_sort(data):    
    for i in range(1,len(data)):
        j = i
        temp = data[i]
        while (j>0 and data[j-1]>temp):
            data[j]=data[j-1]
            j-=1
        data[j] = temp
    return data 

def selection_sort(data):    
    for i in range(0,len(data)):
        minor = i
        for j in range(i+1,len(data)):
            if data[j]<data[minor]:
                minor = j
        data[i],data[minor]=data[minor],data[i]
    return data 

def quick_sort_new(data):
    
    if len(data)<=1:
        return data
    else:
        menores,mayores = divide_data(data,data[0])
        return quick_sort_new(menores) + [data[0]] + quick_sort_new(mayores)
      
        
def divide_data(data,n):    
    menores = []
    mayores = []
    for i in data:
        if i<n:
            menores.append(i)
        elif i>n:
            mayores.append(i)
    return menores,mayores
            
def create_partition(data, start,end):
    refer = start
    pivot_data = data[end-1]
    for i in range (start,end):
        if(data[i]<pivot_data):
            data[i], data[refer]= data[refer], data[i]
            refer+=1    
    data[end-1],data[refer]=data[refer],data[end-1]
    return refer

def quick_sort(data):
    def qs(data, start, end):        
        
        if(start<end):
            refer = create_partition(data, start,end)
            qs(data,start,refer)
            qs(data,refer+1,end)
        return data
    qs(data, 0, len(data))
    return data
            
def merge_sort(data):
    return divide_data_merge(data,0,len(data)-1)
    
def divide_data_merge(data,start,end):
    if(start<=end):
        mid = (start + end)//2
        divide_data_merge(data,start,mid)
        divide_data_merge(data,mid+1,end)
        join_data(data,start,mid,end)
    
    

def join_data(data,start,mid,end):  
    #rejoin = []
    i = start
    j = mid
    k = 0
    while i<mid and j<=end:
        if data[i]<data[j]:
            data[k] = data[i]
            #rejoin.append(data[i])
            i += 1
        else:
            data[k] = data[j]
            #rejoin.append(data[j])
            j += 1
        k += 1
    while(i<mid):
        data[k] = data[i]
        #rejoin.append(data[i])
        i += 1
        k += 1
        
    while(j<=end):
        data[k] = data[j]
        #rejoin.append(data[j])
        j += 1
        k += 1


#[-1, -1, -1, -1, 9, 6, 8]
my_list = [2,5,4,-1,9,6,8]                
#validar el funcionamiento de la union de datos o division de datos
print(merge_sort(my_list))
print(my_list)
#print(quick_sort(my_list))
#print(quick_sort_new(my_list))

#generate_plot(buble_sort)
#generate_plot(buble_sort)
#generate_plot(quick_sort)
#generate_plot(quick_sort_new)
#print(buble_sort(my_list))

